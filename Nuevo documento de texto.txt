""" Núcleo del Framework para la construcción de integraciones.
 
Nucleo que administra el funcionamiento de integraciones creadas con el Framework
de Integracion.
 
"""
import traceback
import sys
import os
from abc import ABC, abstractmethod
import threading
import concurrent.futures
import time
from datetime import datetime, timedelta
from queue import Queue
import copy
from uuid import uuid4
from os import error, path
import json
import logging
from logging.handlers import RotatingFileHandler

from flask import Flask, request
from flask_wtf.csrf import CSRFProtect

################################### SCHEDULE #########################################


class Schedule:
    """ Clase Scheduler.

    Permite  programar la ejecución de una integración.

    Usage:

        from ant_py import Schedule

        schedule = [day, hour, minutes, seconds]
    """
    MONDAY = "MONDAY"
    TUESDAY = "TUESDAY"
    WEDNESDAY = "WEDNESDAY"
    THURSDAY = "THURSDAY"
    FRIDAY = "FRIDAY"
    SATURDAY = "SATURDAY"
    SUNDAY = "SUNDAY"

    DAYS = {
        MONDAY: 0,
        TUESDAY: 1,
        WEDNESDAY: 2,
        THURSDAY: 3,
        FRIDAY: 4,
        SATURDAY: 5,
        SUNDAY: 6}
    DATE_BASE = datetime(2018, 1, 1, 0, 0, 0)
    SECONDS_OF_WEEK = 604800

    schedules = []

    def __init__(self, plan: list = []):
        """ Constructor de la clase. """
        for event in plan:
            if not isinstance(event, list):
                raise Exception("Schedule error: plan must be a list")
            elif len(event) < 4:
                raise Exception(
                    "Schedule error: plan must have 3 items: Day, hour, minutes and seconds")
            else:
                self.add_event(event[0], event[1], event[2], event[3])

    def have_schedule(self):
        """ Valida si se tiene schedules en la ejecución de una integración. """
        if len(self.schedules) == 0:
            return False
        else:
            return True

    def date_differente(self, day: int, hour: int, minute: int, seconds: int):
        """ Calcula la diferencia entre una fecha y hora enviada
        contra la fecha base. """
        date_objetive = datetime(2018, 1, 1 + day, hour, minute, seconds)
        return (date_objetive - self.DATE_BASE).total_seconds()

    def add_event(self, day: str, hour: int, minute: int, seconds: int):
        """ Añade un evento a la lista de schedules """
        if not day.upper() in self.DAYS.keys():
            raise Exception('Wrong day!')

        if hour < 0 or hour > 23:
            raise Exception('Wrong hour!')

        if minute < 0 or minute > 59:
            raise Exception('Wrong minute!')

        if seconds < 0 or seconds > 59:
            raise Exception('Wrong second!')

        difference = self.date_differente(
            self.DAYS[day], hour, minute, seconds)
        position = len(self.schedules)
        for i in range(len(self.schedules)):
            if self.schedules[i] == difference:
                position = -2
                break
            elif self.schedules[i] > difference:
                position = i
                break
        if position > -2:
            self.schedules.insert(position, difference)

    def next_execution(self, actual_date: datetime):
        """ Calcula la próxima ejecución de la integración. """
        if not self.have_schedule():
            return 0, datetime.now()

        difference = self.date_differente(actual_date.weekday(
        ), actual_date.hour, actual_date.minute, actual_date.second)
        next = -1
        for i in range(len(self.schedules)):
            if difference < self.schedules[i]:
                next = i
                break
        if next == -1:
            remaining_seconds = self.SECONDS_OF_WEEK - \
                difference + self.schedules[0]
        else:
            remaining_seconds = self.schedules[next] - difference

        return remaining_seconds, actual_date + timedelta(seconds=remaining_seconds)

#################################### MESSAGE ##########################################


class Message():
    """ Clase constructora del objeto tipo Message.

    Estructura del mensaje de entrada de una integración.

    - header -- dict:
        Contiene información general del mensaje que está siendo procesado.

    - body -- list:
        Contiene la información que hace parte del mensaje; al ser una lista
        se pueden procesar varios datos en un solo mensaje y cada dato
        debería ser puesto en una posición diferente de la lista.
    """

    def __init__(self):
        """ Constructor de la clase. """
        self.header = {}
        self.body = []

#################################### ERROR ##########################################


class Error():
    """ Clase constructora del objeto tipo Error.

    Estructura de los errores que son generados en una integración.

    - step -- str:
        Paso en el que se encontró el error.
    - type -- str:
        Tipo de error, puede ser FUNCTIONAL o TECNICAL.
    - description -- str:
        Descripción del error.
    - sent -- bool:
        Es un booleano que define si el error fue enviado a la trazabilidad para
        su tratamiento o no.
    - body -- list:
        Contiene los datos que generaron el error.
    - id: -- str: Id del error.
    """
    FUNCTIONAL = 'FUNCTIONAL'
    TECNICAL = 'TECNICAL'

    def __init__(self):
        """ Constructor de la clase. """
        trace_back = self.get_trace_back()
        self.tb_lineno = f'{trace_back[0]}: {trace_back[1]}'
        self.funcname = trace_back[2]
        self.source = trace_back[3]
        self.step = ''
        self.type = ''
        self.description = ''
        self.sent = False
        self.body = []
        self.id = ''

    @staticmethod
    def get_trace_back():
        """
        Método que obtiene el ultimo trace generado.

        Returns:
        ----------
        filename: str
            Nombre del archivo donde ocurrió el error.
        linenum: str
            Número de linea donde ocurrió el error.
        funcname: str
            Nombre del método en el cual ocurrió el error.
        source: str
            Linea que generó el error.
        """
        filename, linenum, funcname, source = None, None, None, None
        exc_tb = sys.exc_info()
        last_trace = len(traceback.extract_tb(exc_tb[2]))-1
        filename, linenum, funcname, source = traceback.extract_tb(exc_tb[2])[
            last_trace]
        filename = os.path.basename(filename)
        return filename, linenum, funcname, source

#################################### PACKAGE ##########################################


class Package():
    """ Clase constructora del objeto tipo Package.

    Estructura de los paquetes que son procesados en la integración.

    - general_info -- dict:
        Contiene información general de la integración.
    - message_in -- Message:
        Contiene la información del mensaje que está pasando por la integracion.
    - message_out -- list:
        Contiene la lista de respuestas de la integración.
    - errors -- list:
        Contiene la lista de errores de la integración.
    - status -- str:
        Contiene el estado del mensaje. Puede ser OK, ERROR o CRASH.
    - desc_status -- str:
        Descripción del estado en caso de ERROR o CRASH.
    """
    OK = 'OK'
    CRASH = 'CRASH'
    ERROR = 'ERROR'

    def __init__(self):
        """ Constructor de la clase. """
        self.general_info = {'startTime': datetime.now(), 'messages': 0}
        self.message_in = Message()
        self.message_out = []
        self.errors = []
        self.status = ''
        self.desc_status = ''

#################################### TRACE ##########################################


class Trace():
    """ Clase base que define la forma en la que es manejada la trazabilidad y los errores
    en una integración. """
    # Tipos de trace
    ERROR = 'ERROR'
    INFO = 'INFO'
    DEBUG = 'DEBUG'
    CRASH = 'CRASH'

    # Pipe en el que se genera el trace
    PIPE_IN = 'IN'
    PIPE_OUT = 'OUT'

    # Valor por defecto para la depuración del trace
    DEFAULT_DEPURATION_HOURS = 24

    def __init__(self, **kwargs):
        """ Constructor de la clase. """
        self.__queue = Queue(maxsize=0)
        self.__queue_error = Queue(maxsize=0)
        self.unit_test = False

    @abstractmethod
    def do_trace(self, value):
        """ Se ejecuta cuando se ha invocado un trace de tipo INFO o DEBUG. """

    @abstractmethod
    def error(self, value):
        """ Se ejecuta cuando se ha generado un error en la integración. """

    @abstractmethod
    def crash(self, value):
        """ Se ejecuta cuando se ha generado un error que no permite continuar
        con el procesamiento del mensaje. """

    def start(self, depuration_hours: int = DEFAULT_DEPURATION_HOURS, unit_test: bool = False):
        """ Inicia la ejecución del trace, esta función está buscando permanentemente los
        mensajes que hay en la cola de trazabilidad y de errores, en el momento en que
        encuentra alguna información, ejecuta la función que debe procesar el TRACE o
        ERROR.
        """
        self.unit_test = unit_test
        last_depuration = datetime.now()
        self.trace_init()
        while True:
            if (datetime.now() - last_depuration).total_seconds()/60/60 > depuration_hours:
                last_depuration = datetime.now()
                self.depure()
            if not self.__queue_error.empty():
                value = self.__queue_error.get()
                if value['type'] == self.ERROR:
                    self.error(value)
                else:
                    self.crash(value)
                self.__queue_error.task_done()
            elif not self.__queue.empty():
                value = self.__queue.get()
                if 'end' in value:
                    self.trace_end()
                    break
                if value['type'] == self.INFO or value['type'] == self.DEBUG:
                    self.do_trace(value)
                    if 'package' in value:
                        del value['package']
                self.__queue.task_done()
            else:
                time.sleep(0.2)

    def trace_init(self):
        """ Se ejecuta una vez inicia el trace. """

    def trace_end(self):
        """ Se ejecuta cuando finaliza inicia el trace. """

    def depure(self):
        """ Se ejecuta cada vez que sea necesario hacer depuración del trace. """

    def stop(self):
        """ Debe ser invocada para parar el thread que maneja el trace. """
        self.__queue.put({'end': 'end'})

    @staticmethod
    def validate_elapsed_time(name, package: Package, *args):
        """ Utilizado cuando se quiera hacer un trace por tiempo. """

        trace_name = 'last_trace' + name
        if trace_name in package.general_info:
            last_date = package.general_info[trace_name]
        else:
            last_date = package.general_info['startTime']
        if (datetime.now() - last_date).seconds >= args[0][0]:
            package.general_info[trace_name] = datetime.now()
            valid = True
        else:
            valid = False
        return valid

    @staticmethod
    def validate_number_records(name, package: Package, *args):
        """ Utilizado cuando se quiera hacer trace por número de mensajes. """
        return package.general_info['messages'] % int(args[0][0]) == 0

    def __call__(self, type_trace, pipe, step, transaction_date, **args):
        """ Método usado para ejecutar el trace """
        data = {'type': type_trace,
                'pipe': pipe,
                'step': step,
                'datetime': transaction_date}
        for arg_name, value in args.items():
            data[arg_name] = value
        if type_trace in (Trace.ERROR, Trace.CRASH):
            self.__queue_error.put(data)
        else:
            self.__queue.put(data)

#################################### Source ##########################################


class Source(ABC):
    """ Clase base que define la estructura que debe tener todo adaptador de entrada. """

    def __init__(self, **kwargs):
        """ Inicializa el adaptador de entrada. """
        self.__name = "Source"
        for arg, value in kwargs.items():
            if arg == 'name':
                self.__name = value

    def get_name(self):
        """ Consulta del nombre del adaptador.

        Note:
        Existe por compatibilidad con versiones anteriores, pero no debe ser usada.
        """
        return self.name

    @property
    def name(self):
        """ Consulta del nombre del adaptador. """
        return self.__name

    @name.setter
    def name(self, value: str):
        """ Define el nombre del adaptador. """
        self.name = value

    @abstractmethod
    def __call__(self, executor, package: Package, index: int, tracer):
        """ Ejecuta el adaptador.

        - executor:
            Función que el adaptador debe ejecutar del core, cuando
            tenga un nuevo mensaje para procesar.
        - package:
            Paquete que se envía en la integración.
        - index:
            Número de hilo de ejecución (utilizado para ejecuciones en paralelo).
        - tracer:
            Función que el adaptador debe ejecutar para hacer trace.
        """

#################################### Destination ##########################################


class Destination(ABC):
    """ Clase base que define la estructura que debe tener todo adaptador de salida. """

    def __init__(self, **kwargs):
        """ Inicializa el adaptador de salida. """
        self.__name = 'Destination'
        for arg, value in kwargs.items():
            if arg == 'name':
                self.__name = value

    @property
    def name(self):
        """ Consulta del nombre del adaptador. """
        return self.__name

    @name.setter
    def name(self, value: str):
        """ Define el nombre del adaptador. """
        self.name = value

    def get_name(self):
        """ Consulta del nombre del adaptador.

        Note:
        Existe por compatibilidad con versiones anteriores, pero no debe ser usada. """
        return self.name

    @abstractmethod
    def __call__(self, package: Package, index: int, tracer):
        """ Ejecuta el adaptador.

        - package:
            Paquete que se envía en la integración.
        - index:
            Número de hilo de ejecución (utilizado para ejecuciones en paralelo).
        - tracer:
            Función que el adaptador debe ejecutar para hacer trace.
            Ejecuta el adaptador. """

    def rollback(self):
        """ Se ejecuta cuando en medio de una transacción global, el adaptador debe hacer
            rollback. """

    def commit(self):
        """ Se ejecuta cuando en medio de una transacción global, el adaptador debe hacer
            rollback. """

#################################### Step ##########################################


class Step(ABC):
    """ Clase que define la estructura que deben tener los Steps. """

    def __init__(self, **args):
        """ Inicializa el Step.

        Esta clase es útil para inicializar conexiones y establecer
        parámetros del Step. Aquí también se define el nombre del adaptador. """
        self.__name = 'Step'
        for arg, value in args.items():
            if arg == 'name':
                self.__name = value

    @property
    def name(self):
        """ Consulta del nombre del adaptador. """
        return self.__name

    @abstractmethod
    def __call__(self, package: Package) -> Package:
        """ Consulta el nombre del adaptador. """

################################# Pipe ######################################


class Pipe(ABC):
    """ Clase que define la estructura que tiene los pipes de entrada y salida. """

    def __init__(self, route):
        """ Inicializa el pipe. """
        self.__steps = []
        self.__trace = None
        self.__crash = False
        self.__end_type = ''
        self.__errors = []
        self.__route = route

    def trace(self, name='', validate=None, *args):
        """ Hace un un trace.

        - name (opcional) -- str:
            Nombre del trace.
        - validate (opcional):
            Tipo de validación a realizar, puede ser:
                - Trace.validate_number_records.
                - Trace.validate_elapsed_time.
        - records (opcional):
            Número de registros cuando el validate es: Trace.validate_number_records.
        - time (opcional):
            Tiempo en segundos cuando el validate es: Trace.validate_elapsed_time.
        """
        type_step = {
            'type': 'trace',
            'function': validate,
            'name': name,
            'args': args}
        self.__steps.append(type_step)
        return self

    def _filter(self, arg):
        """ Adiciona un filtro a la ejecución del Route. """
        type_step = {'type': 'filter', 'filter': arg}
        self.__steps.append(type_step)

    @staticmethod
    def validate_filter(package: Package, validation: str):
        """ Filtra la información según la configuración hecha en un step Filter. """
        result = True
        error = False
        desc_error = ""
        response = []
        for body in package.message_in.body:
            try:
                result = eval(validation)
            except Exception as err:
                error = True
                desc_error = "Error in filter: " + str(err)
                break
            if result:
                response.append(body)
        package.message_in.body = response
        return error, desc_error, package

    def step(self, arg):
        """  Instrucción para hacer trace dentro de un Route. """
        if not callable(arg):
            print('NO CALLEABLE')
            self.__crash = True
            self.__errors.append(
                f'Step {str(len(self.__steps) + 1)} is not callable')
        else:
            print('CALLEABLE')
            type_step = {'type': 'runnable', 'function': arg}
            self.__steps.append(type_step)
        return self

    @property
    def _steps(self):
        """ Retona los pasos de un Pipe. """
        return self.__steps

    @classmethod
    def _get_name(cls):
        """ Consulta el nombre del Pipe. """
        return 'Pipe'

    def _crash(self, step, description, package: Package = None):
        """ Hace el trace de un CRASH dentro del Pipe. """
        self.__route._logger.error(self._format_message(description, step))
        try:
            if package:
                if package.general_info.get('tb_lineno') is None:
                    error = Error()
                    description = f'{error.funcname}: {error.source} - {description}'
                    package.general_info['tb_lineno'] = error.tb_lineno
                package.status = package.CRASH
                package.desc_status = description
            if isinstance(self, PipeIn):
                pipe = Trace.PIPE_IN
            else:
                pipe = Trace.PIPE_OUT
            self.__route.trace(
                type_trace=Trace.CRASH,
                pipe=pipe,
                step=step,
                transaction_date=datetime.now(),
                package=copy.deepcopy(package))
        except Exception:
            time.sleep(30)

    # Metodos solo de uso interno del bus
    def _format_message(self, description, step=None, package: Package = None):
        """ Formato del mensaje para el trace. """
        message = '[Route:{}]'.format(self._get_name())
        if step:
            message = message + '[Step:{}]'.format(step)
        message = message + ' - ' + description
        if package:
            message = message + '\n' + '[Payload IN]: ' + \
                str(package.message_in.body) + '\n' + \
                '[Payload OUT]: ' + str(package.message_out)
        return message

    def __validate(self):
        """ Valida si el Pipe finaliza correctamente. """
        if not self.__end_type:
            self.__crash = True
            self.__errors.append('Destination required')

#################################### PIPE IN ##########################################


class PipeIn(Pipe):
    """  Pipe de entrada del Route. """

    def __init__(self, route, pipe_out):
        """ Constructor del Pipe In. """
        super(PipeIn, self).__init__(route)
        self.__route = route
        self.__pipe_out = pipe_out
        self.__destinations = []
        self.__parallel_dest = False
        self.__source = None
        self.__end_type = ''
        self.__errors = []
        self.__tracer = None

    def source(self, arg=None):
        """ Especifica la fuente de la información. """
        if arg:
            if not callable(arg):
                self.__crash = True
                self.__errors.append('Source is not callable')
            else:
                self.__source = arg
        return self

    def _get_name(self):
        """ Consulta el nombre del Pipe. """
        return 'PipeIN'

    def filter(self, arg):
        """ Retorna los steps de filtros. """
        self._filter(arg)
        return self

    def to(self, *args):
        """ Define los destinos. """
        self.__destinations = self.__add_destinations(args, 'end_point')
        self.__parallel_dest = False

    def to_route(self, *args):
        """ Define los destinos cuando son rutas. """
        self.__destinations = self.__add_destinations(args, 'route')
        self.__parallel_dest = False

    def to_parallel(self, *args):
        """ Define los destinos cuando se harán endpoints paralelos. """
        self.__destinations = self.__add_destinations(args, 'end_point')
        self.__parallel_dest = True

    def to_route_parallel(self, *args):
        """ Define los destinos cuando son rutas en paralelo. """
        self.__destinations = self.__add_destinations(args, 'route')
        self.__parallel_dest = True

    def _start_unit_test(self, index):
        """ Inicia la ejecucción para pruebas unitarias. """
        try:
            with open(self.__route.unit_test_file) as test_file:
                data = json.load(test_file)
        except Exception as error:
            return Package.CRASH, "Error reading unit test file: " + \
                str(error) + ". check JSON format"

        try:
            if not isinstance(data, list):
                raise Exception('data in unit test file must be an array')
            package = Package()
            package.general_info['messages'] = len(data)
            package.message_in.body = data
            response = self._execute(package, index)
        except Exception as error:
            return Package.CRASH, str(error)

        return response.status, response.desc_status

    def _start(self, package, index, tracer):
        """ Inicia la ejecucción del Pipe. """
        self.__tracer = tracer
        if self.__source:
            try:
                if self.__route.unit_test:
                    status, description = self._start_unit_test(index)
                else:
                    status, description = self.__source(
                        self._execute, package, index, tracer)
                if status == package.CRASH:
                    self._crash(self.__source.name, description, package)
            except Exception as err:
                self._crash(self.__source.name, str(err), package)
        else:
            if self.__route.unit_test:
                status, description = self._start_unit_test(index)
            else:
                package = self._execute(package, index)

    @property
    def _destinations(self):
        """ Obtiene los destinos que hacen parte del PipeIn. """
        return self.__destinations

    def __send_error_pipe(self, package: Package, step):
        """ Envia los errores que se encuentran dentro del Package"""
        errors = []
        for error in package.errors:
            if not error.sent:
                package.general_info['errors'] = package.general_info['errors'] + 1
                error.id = package.message_in.header.get('id')
                errors.append(copy.deepcopy(error))
                error.sent = True
        if len(errors) > 0:
            self.__route.trace(type_trace=Trace.ERROR, pipe=Trace.PIPE_IN,
                               step=step,
                               transaction_date=datetime.now(),
                               errors=errors
                               )
        package.errors = []

    def __execute_runnable(self, step, package: Package):
        """ Ejecuta steps que se pueden correr """
        is_error = False
        try:
            package = step['function'](package)
            if package.status == package.CRASH:
                self._crash(step['function'].name,
                            package.desc_status, package)
                is_error = True
            elif package.status == package.ERROR or len(package.errors) > 0:
                self.__send_error_pipe(package, step['function'].name)
        except Exception as err:
            self._crash(step['function'].name, str(err), package)
            is_error = True

        return not is_error

    def _execute(self, package: Package, index: int):
        """ Da las ordenes de ejecucción """
        package.message_in.header = {}
        package.message_in.header['startTime'] = datetime.now()
        package.message_in.header["id"] = str(uuid4())
        package.status = Package.OK
        package.desc_status = ''
        is_error = False
        for step in self._steps:
            if step['type'] == 'runnable':
                if not self.__execute_runnable(step, package):
                    is_error = True
                    break
                elif self.__route.unit_test:
                    self.__route.trace(
                        type_trace=Trace.INFO,
                        pipe=Trace.PIPE_IN,
                        step=step['name'],
                        transaction_date=datetime.now(),
                        package=copy.deepcopy(package)
                    )
            elif step['type'] == 'trace':
                trace = True
                if step['function']:
                    trace = step['function'](
                        step['name'], copy.deepcopy(package), step['args'])
                if trace:
                    self.__route.trace(type_trace=Trace.INFO, pipe=Trace.PIPE_IN,
                                       step=step['name'], transaction_date=datetime.now(
                                       ),
                                       package=copy.deepcopy(package)
                                       )
            elif step['type'] == 'filter':
                error, desc_error, package = Pipe.validate_filter(
                    package, step['filter'])
                if error:
                    self._crash("filter", desc_error, package)
                    is_error = True
                    break
                elif self.__route.unit_test:
                    self.__route.trace(type_trace=Trace.INFO, pipe=Trace.PIPE_IN,
                                       step="filter", transaction_date=datetime.now(),
                                       package=copy.deepcopy(package)
                                       )
        if not is_error:
            if self.__parallel_dest:
                self.__execute_dest_parallel(package, self.__end_type, index)
            else:
                self.__execute_dest_serial(package, self.__end_type, index)
            if package.status != Package.CRASH:
                self.__pipe_out._execute(package)
        return package

    # Metodos solo de uso interno del bus
    def __add_destinations(self, args, end_type):
        """ Añade destinos a la lista de destinos """
        destinations = []
        count = 0
        if not self.__end_type:
            for arg in args:
                count += 1
                if not callable(arg) and end_type == 'end_point':
                    self.__crash = True
                    self.__errors.append(
                        'Destination ' + str(count) + ' is not callable')
                else:
                    destinations.append(arg)
        else:
            self.__crash = True
            self.__errors.append('Too many destinations')
        self.__end_type = end_type
        return destinations

    def _execute_route(self, route: callable, package: Package, index: int):
        """ Ejecuta una ruta """
        route.slave = True
        route.trace = self.__route.trace
        route.global_transaction = self.__route.global_transaction
        if self.__route.unit_test:
            route.activate_unit_test(
                self.__route.unit_test_file, self.__route.send_destinations)
        package_dest = copy.deepcopy(package)
        package_out = route.pipe_in()._execute(package_dest, index)
        del package_dest
        return package_out

    def end_transaction(self, confirm: bool):
        """ Termina las transacciones que se encuentran ejecuntandose """
        for destination in self.__destinations:
            if confirm:
                destination.commit()
            else:
                destination.rollback()

    def _execute_end_point(self, end_point: callable, package: Package, index: int):
        """ Ejecuta los endpoints """
        if (not self.__route.unit_test or (self.__route.unit_test
                                           and self.__route.send_destinations)):
            package_dest = copy.deepcopy(package)
            status, desc_status, message = end_point(
                copy.deepcopy(package), index, self._Pipe__route._Route__trace)
            del package_dest
            if status == Package.CRASH and not self.__route.global_transaction:
                self._crash(end_point.name, str(package.desc_status), package)
                package.status = package.ERROR
                error = Error()
                error.step = end_point.name
                error.body = package.message_in.body
                error.description = package.desc_status
                error.sent = False
                package.errors.append(error)
                self.__send_error_pipe(package, end_point.name)

            return status, desc_status, message
        else:
            return Package.OK, '', None

    def __execute_dest_serial(self, package: Package, __end_type, index: int):
        """ Ejecuta los destinos descritos de manera secuencial """
        if __end_type == 'end_point':
            need_rollback = False
            dest_executed = []
            if (not self.__route.unit_test or
                    (self.__route.unit_test and self.__route.send_destinations)):
                for destination in self.__destinations:
                    try:
                        status, desc_status, message = \
                            self._execute_end_point(
                                destination, package, index)
                        package.status = status
                        package.desc_status = desc_status
                        if status == package.CRASH and self.__route.global_transaction:
                            need_rollback = True
                            break
                        else:
                            if not self.__route.global_transaction and not self.__route.slave:
                                destination.commit()
                        dest_executed.append(destination)
                        if status != package.CRASH and message:
                            package.message_out.append(message)
                    except Exception as err:
                        self._crash(destination.name, str(err), package)
                        need_rollback = True
                        break
                if self.__route.global_transaction:
                    for dest in dest_executed:
                        if need_rollback:
                            dest.rollback()
                        elif not self.__route.slave:
                            dest.commit()
        else:
            message_out = []
            dest_executed = []
            for destination in self.__destinations:
                try:
                    package_out = self._execute_route(
                        destination, package, index)
                    if package_out.status == package.CRASH:
                        self._crash(destination.name,
                                    package_out.desc_status, package)
                        if self.__route.global_transaction:
                            for dest in dest_executed:
                                dest.end_transaction(False)
                        break
                    else:
                        for message in package_out.message_out:
                            message_out.append(message)
                        dest_executed.append(destination)
                    del package_out
                except Exception as err:
                    self._crash(destination.name, str(err), package)
                    break
            package.message_out = message_out
        return package

    def __execute_dest_parallel(self, package, __end_type, index: int):
        """ Ejecuta los destinos de forma paralela """
        if __end_type == 'end_point':
            if (not self.__route.unit_test or
                    (self.__route.unit_test and self.__route.send_destinations)):
                need_rollback = False
                package.desc_status = ''
                with concurrent.futures.ThreadPoolExecutor(max_workers=len(self.__destinations))\
                        as executor:
                    result = {executor.submit(self._execute_end_point, destination, package,
                                              index, self.__tracer):
                              destination
                              for destination in self.__destinations}

                    for future in concurrent.futures.as_completed(result):
                        try:
                            status, desc_status, message = future.result()
                            if status in (package.ERROR, package.CRASH):
                                package.status = status
                                package.desc_status = package.desc_status + ' ' + desc_status
                            if status != package.CRASH and message:
                                package.message_out.append(message)
                                need_rollback = True

                        except Exception as exc:
                            self._crash('executing ' + result[future] + ' in parallel',
                                        'exception:' + str(exc), package)
                    if need_rollback:
                        for destination in self.__destinations:
                            destination.rollback()
                    elif self.__route.global_transaction and not self.__route.slave:
                        for destination in self.__destinations:
                            destination.commit()
        else:
            package.desc_status = ''
            need_rollback = False
            with concurrent.futures.ThreadPoolExecutor(max_workers=len(self.__destinations))\
                    as executor:
                result = {executor.submit(self._execute_route, destination, package, index):
                          destination for destination in self.__destinations}
                for future in concurrent.futures.as_completed(result):
                    try:
                        package_out = future.result()
                        if package_out.status in (package_out.ERROR, package_out.CRASH):
                            package.status = package_out.status
                            package.desc_status = package.desc_status + ' '\
                                + package_out.desc_status
                        if package_out.status != package_out.CRASH:
                            package.message_out.append(package_out.message_out)
                            need_rollback = False
                    except Exception as exc:
                        self._crash('executing ' + result[future] + ' in parallel',
                                    'exception:' + str(exc), package)
                    if need_rollback:
                        for destination in self.__destinations:
                            destination.rollback()
                    elif self.__route.global_transaction and not self.__route.slave:
                        for destination in self.__destinations:
                            destination.commit()
        return package

#################################### PIPE OUT ##########################################


class PipeOut(Pipe):
    """ Clase abstracta para el PipeOut """

    def __init__(self, route):
        super(PipeOut, self).__init__(route)
        self.__route = route

    def _get_name(self):
        """ Obtiene el nombre del Pipe """
        return 'PipeOut'

    def _execute(self, package):
        """ Ejecuta el Pipe """
        for step in self._steps:
            if step['type'] == 'runnable':
                try:
                    package = step['function'](package)
                    if package.status == package.CRASH:
                        self._crash(step['function'].name,
                                    package.desc_status, package)
                        break
                except Exception as err:
                    self._crash(step['function'].name, str(err), package)
                    break
            elif step['type'] == 'trace':
                self.__route.trace(type_trace=Trace.INFO, step=step['name'], pipe=Trace.PIPE_OUT,
                                   transaction_date=datetime.now(), package=copy.deepcopy(package))

############################### ROUTE ######################################


class Route():
    """
        Description
        -----------
        Permite definir todos los pasos de una integración.

        Properties
        ----------
        pipe_in (Pipe): Son los pasos necesarios para enviar información desde un origen hasta 1 o
                 varios destinos. Un pipe_in siempre debería comenzar con un source
                 (fuente de la  información) y terminar con un destino (pueden ser adaptadores
                 o nuevos routes).

        pipe_out (Pipe): Son los pasos que procesan las respuestas de las integraciones

        global_transaction (bool): Define si la integración maneja una transacción global
                            para toda la integración (que incluye source y destinos) o no.
"""

    def __init__(self, name):
        self.__crash = False
        self.__errors = []
        self.name = name
        self.__pipe_out = PipeOut(self)
        self.__pipe_in = PipeIn(self, self.__pipe_out)
        self.__trace = None
        self.global_transaction = True
        self.__unit_test = False
        self.__unit_test_file = ""
        self.__send_destinations = False
        self.__slave = False
        self.__logger = Route.create_rotating_log()
        self.__thread_service = None

    @staticmethod
    def create_rotating_log():
        """
            Creates a rotating log
        """
        logger = logging.getLogger("bus")

        handler = RotatingFileHandler(
            "bus.log", maxBytes=209715200, backupCount=5)
        formatter = logging.Formatter(
            '[%(asctime)s]:[%(levelname)s]:%(message)s')
        formatter.datefmt = '%d-%b-%y %H:%M:%S'
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        return logger

    @property
    def _logger(self):

        return self.__logger

    @property
    def slave(self) -> bool:
        return self.__slave

    @slave.setter
    def slave(self, value: bool):
        self.__slave = value

    @property
    def global_transaction(self):
        """
            Descripcion:
        """
        return self.__global_transaction

    @global_transaction.setter
    def global_transaction(self, value: bool):
        """
            Descripcion:
        """
        self.__global_transaction = value

    @property
    def unit_test(self):
        """
            Descripcion:
        """
        return self.__unit_test

    @property
    def unit_test_file(self):
        """
            Descripcion:
        """
        return self.__unit_test_file

    @property
    def send_destinations(self):
        """
            Descripcion:
        """
        return self.__send_destinations

    def activate_unit_test(self, file: str, send_destinations: bool):
        """
            Descripcion:
        """
        if not file:
            raise Exception(
                f'the file not provided, is not possible to run unit test')

        if not path.isfile(file):
            raise Exception(
                f'the file {file} does not exists, is not possible to run unit test')
        self.__unit_test = True
        self.__unit_test_file = file
        self.__send_destinations = send_destinations

    def pipe_in(self) -> PipeIn:
        """
            Descripcion:
        """
        return self.__pipe_in

    def pipe_out(self) -> PipeOut:
        """
            Descripcion:
        """
        return self.__pipe_out

    @property
    def trace(self):
        """
            Descripcion:
        """
        return self.__trace

    @trace.setter
    def trace(self, tracer: callable):
        """
            Descripcion:
        """
        if not callable(tracer):
            self.__crash = True
            self.__errors.append('Trace is not callable')
        else:
            self.__trace = tracer

    def set_trace(self, arg):
        """
            Descripcion:
        """
        self.trace = arg

    @classmethod
    def version(cls):
        """
            Descripcion:
        """
        return '1.0.0'

    def __start_trace(self):
        """
            Descripcion: Inicia la el hilo para el manejo del trace
        """
        thread_trace = threading.Thread(target=self.__trace.start,
                                        args=(self.__trace.DEFAULT_DEPURATION_HOURS,
                                              self.unit_test))
        thread_trace.start()

    def __stop_trace(self):
        """
            Descripcion:
        """
        self.__trace.stop()

    def _do_trace(self, type_trace, pipe, step, description):
        self.__trace(type_trace=type_trace, pipe=pipe, step=step,
                     transaction_date=datetime.now(), description=description
                     )

    def __start(self, threads: int, schedule: Schedule):
        self.__validate()
        if not self.__crash:
            try:
                self.__start_trace()
            except Exception as err:
                self.__errors.append('Error starting trace' + str(err))
                self.__send_error()
                return
            while True:
                if schedule.have_schedule():
                    # if route has a schedula sleep until next date
                    seconds, next_date = schedule.next_execution(
                        datetime.now())
                    time.sleep(seconds)

                if threads == 1:
                        package = Package()
                        # Falta mirar como avisarle a los adaptadores de entrada
                        # que corran una sola vez
                        self.__pipe_in._start(package, 0, self._do_trace)

                else:
                    try:
                        work_lst = []
                        for index in range(threads):
                            package = Package()
                            work_lst.append(threading.Thread(
                                target=self.__pipe_in._start,
                                args=(package, index, self._do_trace,)))
                            work_lst[index].start()

                        for work in work_lst:
                            work.join()

                    except Exception as err:
                        self.__errors.append(
                            'Error creating threads' + str(err))
                        self.__send_error()

                if self.unit_test or not schedule.have_schedule():
                    # Evaluate if route does not hava a schedule or if it is a unit test
                    break

            self.__trace.stop()
            if self.__thread_service:
                self.__thread_service.join()
        else:
            self.__send_error()

    def start(self, schedule: Schedule = Schedule()):
        """
            Procedimiento que inicia la integración con un solo hilo de ejecución
        """
        self.__start(1, schedule)

    def start_parallel(self, threads: int, schedule: Schedule = Schedule()):
        """
            Procedumiento que inicia la integración con varios hilos de ejecución

            args:
                threads (int): número de hilos.
        """
        self.__start(threads, schedule)

    def close(self):
        """
            Descripcion:
        """
        del self.pipe_in
        del self.pipe_out

    def __validate(self):
        """
            Descripcion:
        """
        if not self.__pipe_in._steps and not self.__pipe_in._destinations:
            self.__crash = True
            self.__errors.append('Steps or Destination required')

    def __send_error(self):
        """
            Descripcion:
        """
        for desc_error in self.__errors:
            self._logger.error(desc_error)

    @staticmethod
    def start_service(port: int, executor: callable, version: callable):
        """
            Description:
        """

        csrf = CSRFProtect()
        app = Flask("service")
        csrf.init_app(app)

        @app.route("/version", methods=['GET'])
        def versionREST():
            try:
                response = version()
            except Exception as error:
                response = "Error executing version function " + str(error)
            return response
        if executor is not None:
            @app.route("/", methods=['GET', 'POST'])
            def service():
                response = {'status': 'OK', 'description': ''}
                try:
                    response["status"] = Package.OK
                    response["description"] = 'OK'
                    return response
                except Exception as error:
                    response["status"] = Package.CRASH
                    response["description"] = str(error)
                    return response

    def activate_service(self, port=9991, reprocess=True, version: callable = None):
        """
            Description:
        """
        try:
            import flask
        except Exception as error:
            self.trace(type_trace=Trace.CRASH, pipe=Pipe, step="activate_service: " + str(error),
                       transaction_date=datetime.now(), package=None)
            return
        if version is None:
            version = self.version

        if reprocess:
            reprocess_function = self.__pipe_in._execute
        else:
            reprocess_function = None

        self.__thread_service = threading.Thread(target=Route.start_service,
                                                 args=(port, reprocess_function, version))
        self.__thread_service.start()
        time.sleep(1)
